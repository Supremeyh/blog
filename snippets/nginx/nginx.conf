```
Nginx的配置文件nginx.conf配置详解如下：
 
user nginx nginx ;
# Nginx用户及组：用户 组。
 
worker_processes 8;
# 工作进程：数目。根据硬件调整，通常等于CPU数量或者2倍于CPU。
 
error_log  logs/error.log;  
error_log  logs/error.log  notice;  
# 错误日志：存放路径.  参数[ debug | info | notice | warn | error | crit ] 。
 
pid logs/nginx.pid;
# pid（进程标识符）：存放路径。
 
worker_rlimit_nofile 204800;
# 指定进程可以打开的最大描述符：数目。
 
events {
  use epoll;
  # 使用epoll的I/O 事件模型。nginx针对不同的操作系统，有不同的事件模型

  worker_connections 204800;
  # 每个工作进程的最大连接数量。尽量大，理论上每台nginx服务器的最大连接数为。worker_processes*worker_connections

  keepalive_timeout 60;
  # keepalive超时时间。
  
  open_file_cache max=65535 inactive=60s;
  # 这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。
  
  open_file_cache_valid 80s;
  # 这个是指多长时间检查一次缓存的有效信息。
  
  open_file_cache_min_uses 1;
  # open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如果有一个文件在inactive时间内一次没被使用，它将被移除。

}
 
 
#设定http服务器，利用它的反向代理功能提供负载均衡支持
http
{
  include mime.types;
  # 文件扩展名与文件类型映射表
  
  default_type application/octet-stream;
  # 默认文件类型
  
  log_format main '$remote_addr - $remote_user [$time_local] "$request" '
  '$status $body_bytes_sent "$http_referer" '
  '"$http_user_agent" "$http_x_forwarded_for"';
  log_format log404 '$status [$time_local] $remote_addr $host$request_uri $sent_http_location';
  # 日志格式设置。
  # $remote_addr与$http_x_forwarded_for 反向代理服务器的iP地址；原有客户端的IP地址和原来客户端的请求的服务器地址
  # $remote_user：用来记录客户端用户名称；
  # $time_local： 用来记录访问时间与时区；
  # $request： 用来记录请求的url与http协议；
  # $status： 用来记录请求状态；成功是200，
  # $body_bytes_sent ：记录发送给客户端文件主体内容大小；
  # $http_referer：用来记录从那个页面链接访问过来的；
  # $http_user_agent：记录客户浏览器的相关信息；
  
  access_log  logs/host.access.log  main;
  access_log  logs/host.access.404.log  log404;
  # 用了log_format指令设置了日志格式之后，需要用access_log指令指定日志文件的存放路径；
  
  server_names_hash_bucket_size 128;
  # 服务器名字的hash表大小
  
  client_header_buffer_size 4k;
  # 客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般系统分页都要大于1k。 分页大小可以用命令getconf PAGESIZE 取得。

  client_max_body_size 5m;  
  # 允许客户端请求最大字节数

  client_body_buffer_size 128k; 
  # 缓冲区代理缓存用户端请求最大字节数
  
  large_client_header_buffers 8 128k;
  # 客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。
  
  open_file_cache max=102400 inactive=20s;
  # 指定缓存是否启用。
  open_file_cache_valid 30s; 
  open_file_cache_min_uses 2; 
  open_file_cache_errors on;
  

  autoindex on;
  # 开启目录列表访问，合适下载服务器，默认关闭
  
  sendfile on;
  # 是否调用sendfile函数（zero copy方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。
  
  tcp_nopush on;
  # 防止网路阻塞

  tcp_nodelay on;
  # 防止网络阻塞

  keepalive_timeout 120; 
  # 长连接超时时间，单位是秒  

  fastcgi_connect_timeout 300;
  fastcgi_send_timeout 300;
  fastcgi_read_timeout 300;
  fastcgi_buffer_size 64k;
  fastcgi_buffers 4 64k;
  fastcgi_busy_buffers_size 128k;
  fastcgi_temp_file_write_size 128k;
  # FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度


  gzip on; 
  # 开启gzip压缩输出
  gzip_min_length 1k; 
  # 最小压缩文件大小
  gzip_buffers 4 16k; 
  # 压缩缓冲区
  gzip_http_version 1.0;
  # 压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
  gzip_comp_level 2; 
  # 压缩等级
  gzip_types text/plain application/x-javascript text/css application/xml;
  # 压缩类型，默认就已经包含text/html
  gzip_vary on;


  proxy_connect_timeout 90; 
  # 代理超时时间, nginx和后端服务器连接的超时时间, 发起握手等候响应超时时间
  
  proxy_read_timeout 180;
  # 代理接收超时，连接成功后等候后端服务器响应时间, 也可以说是后端服务器处理请求的时间
  
  proxy_send_timeout 180;
  # 代理发送超时，后端服务器数据回传时间，就是在规定时间之内后端服务器必须传完所有的数据
  
  proxy_buffer_size 256k;
  # 保存用户头信息的缓冲区大小
  
  proxy_buffers 4 256k;
  # 设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k
  
  proxy_temp_file_write_size 256k;
  # 设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长
  
  proxy_temp_path /data0/proxy_temp_dir;
  # proxy_temp_path和proxy_cache_path指定的路径必须在同一分区

  proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g;
  #设置内存缓存空间大小为200MB，1天没有被访问的内容自动清除，硬盘缓存空间大小为30GB。
  
  proxy_intercept_errors on;
  # 表示使nginx阻止HTTP应答代码为400或者更高的应答
  
  upstream bakend {
  server 127.0.0.1:8027;
  server 127.0.0.1:8028;
  server 127.0.0.1:8029;
  hash $request_uri;
}
# nginx的upstream目前支持4种方式的分配：
1、轮询（默认），每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。weight，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
2、ip_hash，每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
3、fair（第三方），按后端服务器的响应时间来分配请求，响应时间短的优先分配。
4、url_hash（第三方），按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
tips:
upstream bakend{#定义负载均衡设备的Ip及设备状态}{
ip_hash;
server 127.0.0.1:9090 down;
server 127.0.0.1:8080 weight=2;
server 127.0.0.1:6060;
server 127.0.0.1:7070 backup;
}
在需要使用负载均衡的server中增加proxy_pass http://bakend/;
每个设备的状态设置为:
1.down表示单前的server暂时不参与负载
2.weight为weight越大，负载的权重就越大。
3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误
4.fail_timeout:max_fails次失败后，暂停的时间。
5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。
nginx支持同时设置多组的负载均衡，用来给不用的server来使用。
client_body_in_file_only设置为On 可以将client post过来的数据记录到文件中用来做debug
client_body_temp_path设置记录文件的目录，可以设置最多3层目录
location对URL进行匹配，可以进行重定向或者进行新的代理 负载均衡

 
# 设定查看Nginx状态的地址
location /NginxStatus {
  stub_status on;
  access_log on;
  auth_basic "NginxStatus";
  auth_basic_user_file conf/htpasswd;
}

}


```